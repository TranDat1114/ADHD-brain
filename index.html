<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mô phỏng Suy Nghĩ (ADHD)</title>
    <meta name="description"
        content="Trình diễn tương tác mô phỏng cách luồng suy nghĩ phân nhánh, nhảy cóc của một bộ não ADHD." />
    <style>
        :root {
            --bg: #0d1117;
            --panel: #161b22;
            --panel-border: #30363d;
            --text: #e6edf3;
            --accent: #ffb347;
            --accent2: #8be9fd;
            --danger: #ff5555;
            --memory: #bd93f9;
            --idea: #50fa7b;
            --task: #f1fa8c;
            --distraction: #ff79c6;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif;
        }

        * {
            box-sizing: border-box;
        }

        kbd {
            font-family: monospace;
            background-color: #f4f4f4;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 2px 4px;
            color: #333;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            min-height: 100svh;
            display: flex;
            overflow: hidden;
        }

        h1 {
            font-size: 1.1rem;
            margin: 0 0 .5rem;
            letter-spacing: .5px;
        }

        #sidebar {
            width: 320px;
            /* điều chỉnh gần lũy thừa 2 */
            background: var(--panel);
            border-right: 1px solid var(--panel-border);
            padding: 16px 16px;
            /* 16 */
            display: flex;
            flex-direction: column;
            gap: 16px;
            /* 16 */
            box-shadow: 4px 0 12px -6px #0009;
            transition: transform .35s ease, width .3s ease;
            will-change: transform;
            z-index: 1150;
            position: relative;
            height: 100svh;
            /* full height để có footer cố định */
        }

        #sidebar .sb-head {
            flex: 0 0 auto;
        }

        #sidebar .sb-body {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
            min-height: 0;
        }

        /* cho phép body cuộn riêng nếu quá dài (desktop) */
        @media (min-width: 901px) {
            #sidebar .sb-body {
                overflow-y: visible;
            }
        }

        #sidebar .sb-foot {
            flex: 0 0 auto;
            margin-top: auto;
            font-size: 0.62rem;
            text-align: center;
            opacity: .7;
            padding-top: 4px;
        }

        #sidebar .sb-foot a {
            color: var(--accent2);
            text-decoration: none;
        }

        body.sidebar-collapsed #sidebar {
            transform: translateX(-100%);
            /* Loại khỏi flow flex để không chiếm chỗ khi ẩn (desktop) */
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            pointer-events: none;
            /* tránh chặn click khu vực bên dưới */
        }

        .nav-toggle {
            position: fixed;
            top: 50%;
            left: 300px;
            /* near sidebar edge */
            /* transform: translateY(-50%); */
            z-index: 1400;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent2) 100%);
            color: #111;
            border: 1px solid var(--panel-border);
            box-shadow: 0 2px 6px -2px #000c;
            padding: 6px 8px;
            border-radius: 10px;
            /* đổi thành bo góc vuông mềm */
            width: 42px;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: left .35s ease, background .3s ease, color .3s ease;
        }

        body.sidebar-collapsed .nav-toggle {
            left: 16px;
            /* giữ cố định khi sidebar bị loại khỏi flow */
            background: #222;
            color: var(--text);
        }

        body.show-backdrop #backdrop {
            opacity: 1;
            visibility: visible;
        }

        .mt-1 {
            margin-top: 1rem;
        }

        /* removed stray margin-left */
        #sim-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            user-select: none;
            transition: margin-left .35s ease, width .35s ease;
        }

        /* Khi sidebar hiển thị (desktop), phần mô phỏng vẫn flex chiếm phần còn lại. Khi ẩn phải phủ full */
        body.sidebar-collapsed #sim-container {
            margin-left: 0 !important;
            width: 100vw;
        }

        #view {
            position: absolute;
            inset: 0;
            transform-origin: 0 0;
        }

        #canvasArea {
            position: absolute;
            inset: 0;
        }

        #nodesLayer {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .node {
            position: absolute;
            padding: 6px 10px;
            border-radius: 20px;
            font-size: .75rem;
            line-height: 1.2;
            max-width: 160px;
            backdrop-filter: blur(6px);
            background: #ffffff10;
            border: 1px solid #ffffff20;
            color: var(--text);
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 2px 6px -2px #000a, 0 0 0 1px #0005;
            transition: transform .35s cubic-bezier(.22, 1.56, .42, .92), filter .4s, opacity .6s;
        }

        .node.task {
            border-color: var(--task);
        }

        .node.idea {
            border-color: var(--idea);
        }

        .node.memory {
            border-color: var(--memory);
        }

        .node.distraction {
            border-color: var(--distraction);
        }

        .node.active {
            outline: 2px solid var(--accent2);
            z-index: 1000;
            transform: scale(1.2);
        }

        .node.fading {
            opacity: .25;
            filter: blur(1px);
        }

        .node img {
            max-width: 100%;
            border-radius: 10px;
            display: block;
            margin-top: 4px;
        }

        #controls label {
            display: flex;
            flex-direction: column;
            font-size: .7rem;
            text-transform: uppercase;
            gap: 2px;
            letter-spacing: .5px;
        }

        #controls input[type=range] {
            width: 100%;
        }

        #controls {
            display: grid;
            gap: 10px;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
        }

        button,
        .pill {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent2) 100%);
            border: none;
            color: #111;
            font-weight: 600;
            padding: 8px 16px;
            /* 8 x 16 */
            border-radius: 10px;
            /* chuẩn bo góc */
            cursor: pointer;
            font-size: .8rem;
            letter-spacing: .5px;
            box-shadow: 0 2px 4px -1px #000c;
        }

        button.secondary {
            background: #222;
            color: var(--text);
            border: 1px solid var(--panel-border);
        }

        button:active {
            transform: translateY(1px);
        }

        #sequence {
            /* bỏ flex:1 để đặt chiều cao cố định linh hoạt */
            background: #0b0f14;
            border: 1px solid var(--panel-border);
            padding: 8px 10px;
            overflow-y: auto;
            overflow-x: hidden;
            font-size: .7rem;
            line-height: 1.4;
            border-radius: 8px;
            height: clamp(128px, 32svh, 256px);
            /* dùng 128 - 256 */
            position: relative;
            scrollbar-width: thin;
            scrollbar-color: var(--accent2) #111;
        }

        #sequence::after {
            /* hiệu ứng bóng cho biết còn nội dung */
            content: "";
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 20px;
            pointer-events: none;
            background: linear-gradient(to top, #0b0f14 40%, #0b0f1400);
            border-radius: 0 0 8px 8px;
        }


        #sequence b {
            color: var(--accent2);
        }

        #sequence .jump {
            color: var(--danger);
        }

        #legend {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            font-size: .6rem;
        }

        #legend span {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 40px;
            background: #1f2530;
        }

        #legend i {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }

        #statusLine {
            font-size: .65rem;
            opacity: .7;
        }

        #addThoughtForm {
            display: flex;
            gap: 6px;
        }

        #addThoughtForm input {
            flex: 1;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid var(--panel-border);
            background: #0b0f14;
            color: var(--text);
            font-size: .75rem;
        }

        .disclaimer {
            font-size: .6rem;
            opacity: .6;
            line-height: 1.3;
        }

        #focusHalo {
            position: absolute;
            width: 128px;
            /* 128 */
            aspect-ratio: 1;
            border: 2px dashed var(--accent2);
            border-radius: 50%;
            pointer-events: none;
            mix-blend-mode: color-dodge;
            filter: drop-shadow(0 0 6px var(--accent2));
            animation: pulse 3s linear infinite;
            opacity: .55;
        }

        @keyframes pulse {
            0% {
                transform: scale(.8) rotate(0deg);
            }

            50% {
                transform: scale(1.15) rotate(180deg);
            }

            100% {
                transform: scale(.8) rotate(360deg);
            }
        }

        #overlayMsg {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000c;
            font-size: 1.2rem;
            letter-spacing: 1px;
            visibility: hidden;
            opacity: 0;
            transition: .6s;
        }

        #overlayMsg.show {
            visibility: visible;
            opacity: 1;
        }

        #camHUD {
            position: absolute;
            top: 6px;
            left: 8px;
            background: #0009;
            padding: 4px 8px;
            font-size: .6rem;
            border: 1px solid #222;
            border-radius: 6px;
            pointer-events: none;
            backdrop-filter: blur(4px);
            line-height: 1.2;
        }

        a.inline {
            color: var(--accent2);
        }

        .blink {
            animation: blink 1.2s steps(2, start) infinite;
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        /* Scrollbar tweak */
        #sequence::-webkit-scrollbar {
            width: 6px;
        }

        #sequence::-webkit-scrollbar-track {
            background: #111;
        }

        #sequence::-webkit-scrollbar-thumb {
            background: linear-gradient(var(--accent2), var(--accent));
            border-radius: 6px;
        }


        /* Responsive */
        @media (max-width: 900px) {
            body {
                flex-direction: row;
            }

            #sidebar {
                position: fixed;
                top: 0;
                left: 0;
                bottom: 0;
                width: 275px;
                max-width: 80%;
                border-right: 1px solid var(--panel-border);
                border-bottom: none;
                overflow-y: auto;
                overscroll-behavior: contain;
            }

            body.sidebar-collapsed #sidebar {
                box-shadow: none;
            }

            .nav-toggle {
                top: 50%;
                left: 265px;
                width: 40px;
                height: 40px;
            }

            body.sidebar-collapsed .nav-toggle {
                left: 12px;
                top: 50%;
            }

            #sim-container {
                flex: 1;
            }

            body:not(.sidebar-collapsed) #sim-container {
                margin-left: 275px;
                width: calc(100vw - 275px);
            }

            body.sidebar-collapsed #sim-container {
                margin-left: 0;
                width: 100vw;
            }

            #sequence {
                height: 150px;
            }
        }

        @media (max-width: 520px) {
            h1 {
                font-size: .95rem;
            }

            button,
            .pill {
                padding: 6px 12px;
                font-size: .72rem;
            }

            #controls {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }

            #sequence {
                font-size: .62rem;
            }

            .nav-toggle {
                font-size: .85rem;
            }
        }
    </style>
</head>

<body>
    <div id="backdrop"></div>
    <button id="navToggle" class="nav-toggle" aria-label="Thu gọn menu" title="Thu gọn / Mở menu"
        aria-expanded="true">◀</button>
    <aside id="sidebar">
        <div class="sb-head">
            <h1>Dòng Suy Nghĩ (ADHD)</h1>
            <div id="legend">
                <span><i style="background:var(--task);"></i> Việc đang làm</span>
                <span><i style="background:var(--idea);"></i> Ý tưởng</span>
                <span><i style="background:var(--memory);"></i> Ký ức</span>
                <span><i style="background:var(--distraction);"></i> Phân tâm</span>
            </div>
        </div>
        <div class="sb-body">
            <div id="controls">
                <label>Tốc độ
                    <input id="speed" type="range" min="0.2" max="2.2" step="0.2" value="1" />
                </label>
                <label>Mức phân nhánh
                    <input id="branch" type="range" min="0" max="1" step="0.05" value="0.5" />
                </label>
                <label>Độ lộn xộn
                    <input id="chaos" type="range" min="0" max="1" step="0.05" value="0.4" />
                </label>
                <label>Độ lưu giữ
                    <input id="retention" type="range" min="5" max="60" step="1" value="25" />
                </label>
            </div>
            <div style="display:flex; gap:8px; flex-wrap:wrap;">
                <button id="toggleBtn">TẠM DỪNG</button>
                <button id="jumpBtn" class="secondary" title="Kích hoạt một cú nhảy cóc ngẫu nhiên">Nhảy cóc ⚡</button>
                <button id="resetBtn" class="secondary" title="Xóa & bắt đầu lại">Làm mới</button>
            </div>
            <form id="addThoughtForm" autocomplete="off">
                <input id="newThought" placeholder="Thêm ý nghĩ của bạn..." />
                <button type="submit">+</button>
            </form>
            <div id="statusLine">Trạng thái: <span id="status">đang chạy</span> <span class="blink">●</span></div>
            <div id="sequence" aria-live="polite"></div>
            <div class="disclaimer">Mô phỏng mang tính minh họa nhằm giúp hình dung sự phân nhánh và nhảy cóc trong
                luồng
                suy nghĩ ADHD.
                <br /><strong>Không phải công cụ chẩn đoán y khoa.</strong>
            </div>
            <div class="disclaimer">
                <p>Giữ nút <kbd>Ctrl</kbd> và cuộn <kbd>chuột giữa</kbd> để phóng to/thu nhỏ.</p>
                <p class="mt-1">Giữ nút <kbd>Alt</kbd> và giữ <kbd>chuột trái</kbd> để di chuyển vùng nhìn.</p>
            </div>
        </div>
        <div class="sb-foot">
            Tác giả: <a href="https://github.com/TranDat1114" target="_blank">TranDat1114</a>
        </div>
    </aside>
    <main id="sim-container">
        <div id="view">
            <svg id="canvasArea" width="100%" height="100%"></svg>
            <div id="nodesLayer"></div>
            <div id="focusHalo" hidden></div>
        </div>
        <div id="overlayMsg">TẠM DỪNG</div>
        <div id="camHUD">pan: 0,0<br>zoom: 1.00x</div>
    </main>
    <script>
        // ================== CẤU HÌNH CƠ BẢN ==================
        const TYPES = ['task', 'idea', 'memory', 'distraction'];
        const STARTER_SCENARIO = [
            { text: 'Đang rửa bát...', type: 'task' },
            { text: 'Ý tưởng kinh doanh hộp đựng xà phòng tự động', type: 'idea' },
            { text: 'Ký ức lớp 5: tiết Thủ công', type: 'memory' }
        ];
        const container = document.getElementById('sim-container');
        const svg = document.getElementById('canvasArea');
        const nodesLayer = document.getElementById('nodesLayer');
        const viewEl = document.getElementById('view');
        const camHUD = document.getElementById('camHUD');
        const sequenceEl = document.getElementById('sequence');
        const focusHalo = document.getElementById('focusHalo');
        const overlayMsg = document.getElementById('overlayMsg');
        const statusEl = document.getElementById('status');
        const controls = {
            speed: document.getElementById('speed'),
            branch: document.getElementById('branch'),
            chaos: document.getElementById('chaos'),
            retention: document.getElementById('retention')
        };
        const buttons = {
            toggle: document.getElementById('toggleBtn'),
            jump: document.getElementById('jumpBtn'),
            reset: document.getElementById('resetBtn')
        };
        const addForm = document.getElementById('addThoughtForm');
        const newThoughtInput = document.getElementById('newThought');
        // Đã loại bỏ nút chuyển chế độ cuộn ngang

        let thoughts = new Map(); // id -> object
        let edges = []; // {from,to,line}
        let running = true;
        let activeId = null;
        let nextId = 1;
        let lastSpawn = 0;
        const spawnBaseInterval = 1024; // ms (2^10 approximated)
        const focusSwitchBase = 2048; // ms (2^11)
        let lastFocusSwitch = 0;
        const maxNodes = 250;
        const padding = 64; // 2^6

        function rand(a = 0, b = 1) { return a + Math.random() * (b - a); }
        function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
        function el(html) { const t = document.createElement('template'); t.innerHTML = html.trim(); return t.content.firstElementChild; }

        // ================== KHỞI TẠO ==================
        function initScenario() {
            thoughts.clear(); edges.forEach(e => e.line.remove()); edges = []; nodesLayer.innerHTML = ''; sequenceEl.innerHTML = '';
            activeId = null; nextId = 1; lastSpawn = lastFocusSwitch = performance.now();
            STARTER_SCENARIO.forEach((seed, i) => {
                spawnThought(seed.text, seed.type, null, { x: rand(padding, container.clientWidth - padding), y: rand(padding, container.clientHeight - padding) }, true);
                if (i === 0) activeId = 1; // first one
            });
            writeSequence('<b>Bắt đầu:</b> Đang rửa bát...');
            focusOn(activeId);
        }

        // ================== TẠO Ý NGHĨ ==================
        function spawnThought(text, type, parentId = null, presetPos = null, silent = false) {
            if (thoughts.size >= maxNodes) trimOld();
            const id = nextId++;
            const angle = rand(0, Math.PI * 2);
            const dist = rand(50, 180);
            let x, y;
            if (presetPos) { ({ x, y } = presetPos); } else if (parentId && thoughts.get(parentId)) {
                const p = thoughts.get(parentId);
                x = p.x + Math.cos(angle) * dist; y = p.y + Math.sin(angle) * dist;
            } else {
                x = rand(padding, container.clientWidth - padding);
                y = rand(padding, container.clientHeight - padding);
            }
            // wrap inside boundaries by reflecting
            x = Math.min(container.clientWidth - padding, Math.max(padding, x));
            y = Math.min(container.clientHeight - padding, Math.max(padding, y));

            const nodeEl = el(`<div class="node ${type}" data-id="${id}">${text}</div>`);
            nodesLayer.appendChild(nodeEl);
            const thought = { id, text, type, parentId, x, y, created: performance.now(), element: nodeEl, children: [], focusLocks: 0 };
            thoughts.set(id, thought);
            if (parentId && thoughts.get(parentId)) thoughts.get(parentId).children.push(id);
            positionNode(thought);
            // Sau khi render mới biết kích thước thật => kẹp lại vào trong viewport
            clampWithin(thought);
            positionNode(thought);
            nodeEl.addEventListener('click', () => { manualFocus(id); });
            if (parentId) { createEdge(parentId, id); }
            if (!silent) fadeLogic();
            return id;
        }

        // ================== VẼ & CẬP NHẬT ==================
        function positionNode(t) {
            t.element.style.transform = `translate(${t.x}px,${t.y}px)`;
        }
        function createEdge(from, to) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            const a = thoughts.get(from); const b = thoughts.get(to);
            const same = a && b && a.type === b.type;
            const stroke = same ? 'rgba(255,255,255,0.18)' : `var(--${b?.type || 'accent2'})`;
            line.setAttribute('stroke', stroke);
            line.setAttribute('stroke-width', same ? '1' : '1.6');
            line.setAttribute('stroke-linecap', 'round');
            line.setAttribute('stroke-opacity', same ? '0.9' : '0.85');
            svg.appendChild(line);
            edges.push({ from, to, line });
            updateEdgePosition(edges[edges.length - 1]);
        }
        function updateEdgePosition(e) {
            const a = thoughts.get(e.from); const b = thoughts.get(e.to); if (!a || !b) return;
            e.line.setAttribute('x1', a.x + 40); e.line.setAttribute('y1', a.y + 20); e.line.setAttribute('x2', b.x + 40); e.line.setAttribute('y2', b.y + 20);
        }
        function updateAllEdges() { edges.forEach(updateEdgePosition); }

        function fadeLogic() {
            const retention = parseFloat(controls.retention.value) * 1000; // ms
            const now = performance.now();
            thoughts.forEach(t => {
                const age = now - t.created;
                const fadeStart = retention * 0.6;
                if (age > retention) {
                    // remove
                    t.element.remove();
                    thoughts.delete(t.id);
                } else if (age > fadeStart) {
                    t.element.classList.add('fading');
                }
            });
            // remove edges whose nodes gone
            edges = edges.filter(e => {
                if (!thoughts.has(e.from) || !thoughts.has(e.to)) { e.line.remove(); return false; }
                return true;
            });
            // Nếu active bị xóa, chọn thought mới (ưu tiên thought mới nhất)
            if (activeId && !thoughts.has(activeId)) {
                const remaining = Array.from(thoughts.values()).sort((a, b) => b.created - a.created);
                activeId = remaining.length ? remaining[0].id : null;
                if (activeId) {
                    focusOn(activeId);
                } else {
                    focusHalo.hidden = true;
                }
            }
        }
        function trimOld() {
            // remove oldest 10
            const arr = Array.from(thoughts.values()).sort((a, b) => a.created - b.created).slice(0, 10);
            arr.forEach(t => { t.element.remove(); thoughts.delete(t.id); });
            edges = edges.filter(e => thoughts.has(e.from) && thoughts.has(e.to));
        }

        // ================== FOCUS / JUMP ==================
        function focusOn(id) {
            if (!thoughts.has(id)) return;
            if (activeId && thoughts.get(activeId)) thoughts.get(activeId).element.classList.remove('active');
            activeId = id;
            const t = thoughts.get(id);
            t.element.classList.add('active');
            focusHalo.hidden = false;
            focusHalo.style.left = (t.x + 10) + 'px';
            focusHalo.style.top = (t.y - 20) + 'px';
            // occasionally jitter halo to show micro-shifts
        }
        function manualFocus(id) {
            focusOn(id);
            // temporarily lock (prevent auto switch for short time)
            const t = thoughts.get(id); t.focusLocks++;
            setTimeout(() => { t.focusLocks = Math.max(0, t.focusLocks - 1); }, 1600);
            writeSequence(`<span class='jump'>[Nhấp]</span> ${escapeHtml(t.text)}`);
        }
        function randomJump(force = false) {
            const arr = Array.from(thoughts.keys()).filter(i => i !== activeId);
            if (arr.length === 0) return;
            const target = pick(arr);
            focusOn(target);
            const t = thoughts.get(target);
            writeSequence(`<span class='jump'>[Nhảy cóc]</span> ${escapeHtml(t.text)}`);
            if (force) { t.focusLocks++; setTimeout(() => { t.focusLocks = Math.max(0, t.focusLocks - 1); }, 900); }
        }

        // ================== SEQUENCE LOG ==================
        function writeSequence(html) {
            const div = document.createElement('div');
            div.innerHTML = html;
            sequenceEl.appendChild(div);
            sequenceEl.scrollTop = sequenceEl.scrollHeight;
        }
        function escapeHtml(s) { return s.replace(/[&<>]/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[c])); }

        // ================== VÒNG LẶP ==================
        let worldWidth = 4096, worldHeight = 3072; // dùng kích thước lũy thừa 2 gần (4096x3072)
        let lastFrame = performance.now();
        function loop(now) {
            const dt = Math.min(0.06, (now - lastFrame) / 1000); // giây
            lastFrame = now;
            if (running) {
                const speed = parseFloat(controls.speed.value);
                if (now - lastSpawn > spawnBaseInterval / speed) { generateNext(); lastSpawn = now; }
                if (now - lastFocusSwitch > focusSwitchBase / (speed * rand(0.5, 1.4))) { autoSwitchFocus(); lastFocusSwitch = now; }
                physicsStep(dt);
                updateAllEdges();
                fadeLogic();
                applyCamera();
            }
            requestAnimationFrame(loop);
        }

        function autoSwitchFocus() {
            if (!activeId) return;
            const t = thoughts.get(activeId);
            if (t && t.focusLocks > 0) return; // locked by user
            const chaos = parseFloat(controls.chaos.value);
            if (Math.random() < chaos * 0.6) {
                randomJump();
            } else {
                // pick a child if any, else a sibling
                if (t && t.children.length && Math.random() < 0.7) {
                    const cid = pick(t.children);
                    focusOn(cid);
                    writeSequence(`<b>Chuyển tiếp</b> → ${escapeHtml(thoughts.get(cid).text)}`);
                } else {
                    randomJump();
                }
            }
        }

        function generateNext() {
            if (!activeId) return;
            let current = thoughts.get(activeId);
            if (!current) {
                // Active đã biến mất do fade: chọn thought gần nhất còn lại
                const remaining = Array.from(thoughts.values()).sort((a, b) => b.created - a.created);
                if (!remaining.length) return;
                focusOn(remaining[0].id);
                current = remaining[0];
            }
            const branchProb = parseFloat(controls.branch.value);
            const chaos = parseFloat(controls.chaos.value);
            let newType;
            try {
                newType = chooseNextType(current.type, current.text, chaos);
            } catch (e) {
                newType = pick(TYPES);
            }
            if (!newType || !TYPES.includes(newType)) newType = pick(TYPES);
            const text = synthesizeThought(newType, chaos, current || { text: '', type: pick(TYPES) });
            const newId = spawnThought(text, newType, activeId);
            // Nhánh thêm: tìm node trước có sự liên quan
            if (Math.random() < branchProb * 0.45) {
                const candidatePool = Array.from(thoughts.values()).filter(t => t.id !== activeId && t.children.length < 6);
                if (candidatePool.length) {
                    const firstWord = text.split(' ')[0].toLowerCase();
                    const scored = candidatePool.map(t => {
                        let score = 0;
                        if (t.type === newType) score += 2;
                        if (t.text.toLowerCase().includes(firstWord)) score += 1.5;
                        score += Math.random() * 0.5;
                        return { t, score };
                    }).sort((a, b) => b.score - a.score);
                    const origin = scored[0].t;
                    if (origin) {
                        const extraType = chooseNextType(origin.type, origin.text, chaos * 0.9);
                        const extraText = synthesizeThought(extraType, chaos * 1.1, origin);
                        spawnThought(extraText, extraType, origin.id);
                    }
                }
            }
        }

        // =============== TẠO NỘI DUNG VĂN BẢN GIẢ LẬP ===============
        const FRAGMENTS = {
            task: [
                'rửa bát', 'lau bọt', 'nước ấm', 'cọ xoong', 'xếp đĩa', 'dọn kệ', 'mụn bọt li ti', 'cần mua nước rửa mới',
                'lau bàn bếp', 'nồi inox xước', 'miếng bọt biển mòn', 'nước chảy tràn', 'vòi nước rỉ', 'ổ điện gần bồn', 'tái chế chai nhựa', 'ghi chú cần mua muối rửa',
                'đếm số đĩa', 'thử sắp xếp gọn hơn', 'cảm giác nước ấm dễ chịu'
            ],
            idea: [
                'startup', 'ứng dụng AI', 'tự động hóa', 'cảm biến', 'gọi vốn', 'làm MVP', 'domain còn trống?', 'marketing du kích', 'mã nguồn mở?',
                'tối ưu quy trình', 'gamification', 'dashboard realtime', 'API public', 'thiết kế onboarding', 'flow giữ chân user',
                'subscription tier', 'microservice?', 'chạy trên edge', 'tối ưu chi phí cloud', 'plugin cộng đồng', 'AI phân loại', 'chấm điểm thói quen'
            ],
            memory: [
                'hồi lớp 5', 'tiết Thủ công', 'bạn bàn cười', 'mùi phấn viết', 'trống trường', 'giờ ra chơi', 'màu áo đồng phục',
                'tiếng ve hè', 'ván trượt cũ', 'cái hộp bút sọc', 'cổng trường ồn ào', 'mưa đầu năm học', 'phòng thí nghiệm nhỏ', 'huy hiệu thi đua',
                'bài kiểm tra bất ngờ', 'lần đầu thuyết trình'
            ],
            distraction: [
                'tiếng chim', 'thông báo điện thoại', 'đèn nhấp nháy', 'đói bụng', 'bài hát mắc kẹt', 'tab trình duyệt khác', 'gió luồn qua cửa', 'ý nghĩ lan man',
                'ghế kêu cót két', 'mùi cà phê', 'tin nhắn chưa trả lời', 'cần kiểm tra mail', 'cảm giác ngứa nhẹ', 'ánh sáng màn hình chói',
                'tò mò cập nhật mới', 'cơn rung phantom'
            ]
        };
        const KEYWORD_HINTS = [
            { pattern: /rửa|lau|cọ|sắp xếp|tự động/i, to: 'idea', weight: 3 },
            { pattern: /startup|AI|tự động hóa|MVP|API|microservice/i, to: 'memory', weight: 1.4 },
            { pattern: /mùi phấn|trống trường|lớp 5|học/i, to: 'distraction', weight: 1.6 },
            { pattern: /thông báo|tin nhắn|mail|tab|cập nhật/i, to: 'task', weight: 1.8 }
        ];
        const TRANSITION = {
            task: { task: 0.35, idea: 0.35, memory: 0.10, distraction: 0.20 },
            idea: { task: 0.18, idea: 0.32, memory: 0.30, distraction: 0.20 },
            memory: { task: 0.15, idea: 0.30, memory: 0.30, distraction: 0.25 },
            distraction: { task: 0.25, idea: 0.28, memory: 0.12, distraction: 0.35 }
        };
        function weightedPick(obj) {
            const entries = Object.entries(obj);
            const sum = entries.reduce((a, [, w]) => a + w, 0);
            let r = Math.random() * sum;
            for (const [k, w] of entries) { if ((r -= w) <= 0) return k; }
            return entries[0][0];
        }
        function chooseNextType(currentType, currentText, chaos) {
            let base = { ...TRANSITION[currentType] };
            const flat = chaos * 0.5;
            if (flat > 0) {
                const keys = Object.keys(base); const avg = Object.values(base).reduce((a, b) => a + b, 0) / keys.length;
                keys.forEach(k => base[k] = base[k] * (1 - flat) + avg * flat);
            }
            KEYWORD_HINTS.forEach(rule => { if (rule.pattern.test(currentText)) base[rule.to] = (base[rule.to] || 0) * rule.weight + 0.01; });
            return weightedPick(base);
        }
        function synthesizeThought(type, chaos, prevThought) {
            const arr = FRAGMENTS[type] || ['...'];
            const used = new Set();
            let primary = pick(arr); used.add(primary);
            if (prevThought) {
                const lower = prevThought.text.toLowerCase();
                const rel = arr.filter(f => !used.has(f) && lower.includes(f.split(' ')[0].toLowerCase()));
                if (rel.length && Math.random() < 0.6) primary = rel[Math.floor(Math.random() * rel.length)];
            }
            const pieces = [primary];
            if (Math.random() < 0.45 + chaos * 0.25) pieces.push(pick(arr));
            if (Math.random() < chaos * 0.35) pieces.push(pick(pick(Object.values(FRAGMENTS))));
            let s = pieces.join(' · ');
            if (Math.random() < chaos * 0.2) s = s.charAt(0).toUpperCase() + s.slice(1);
            return s;
        }

        // =============== CHUYỂN ĐỘNG NHẸ ===============
        function physicsStep(dt) {
            const speed = parseFloat(controls.speed.value);
            thoughts.forEach(t => {
                if (typeof t.vx === 'undefined') { t.vx = (Math.random() - 0.5) * 40; t.vy = (Math.random() - 0.5) * 40; }
                const jitter = 5 * speed;
                t.vx += (Math.random() - 0.5) * jitter;
                t.vy += (Math.random() - 0.5) * jitter;
                t.vx *= 0.985; t.vy *= 0.985; // ma sát
                t.x += t.vx * dt; t.y += t.vy * dt;
                const w = t.element.offsetWidth || 120; const h = t.element.offsetHeight || 40;
                if (t.x < 10) { t.x = 10; t.vx = Math.abs(t.vx) * 0.78; }
                if (t.y < 10) { t.y = 10; t.vy = Math.abs(t.vy) * 0.78; }
                if (t.x + w > worldWidth - 10) { t.x = worldWidth - w - 10; t.vx = -Math.abs(t.vx) * 0.78; }
                if (t.y + h > worldHeight - 10) { t.y = worldHeight - h - 10; t.vy = -Math.abs(t.vy) * 0.78; }
                positionNode(t);
            });
            if (activeId && thoughts.has(activeId)) {
                const at = thoughts.get(activeId);
                focusHalo.style.left = (at.x + 10) + 'px';
                focusHalo.style.top = (at.y - 20) + 'px';
            }
        }
        // =============== KẸP NODE VÀO VÙNG HIỂN THỊ ===============
        function clampWithin(t) {
            const w = t.element.offsetWidth || 120;
            const h = t.element.offsetHeight || 40;
            const margin = 12; // lề an toàn trong world
            const maxX = worldWidth - w - margin;
            const maxY = worldHeight - h - margin;
            t.x = Math.min(maxX, Math.max(margin, t.x));
            t.y = Math.min(maxY, Math.max(margin, t.y));
        }
        function clampAll() { thoughts.forEach(t => { clampWithin(t); positionNode(t); }); updateAllEdges(); }

        // =============== SỰ KIỆN UI ===============
        const navToggleBtn = document.getElementById('navToggle');
        const backdrop = document.getElementById('backdrop');
        function setSidebarCollapsed(collapsed) {
            document.body.classList.toggle('sidebar-collapsed', collapsed);
            const small = window.matchMedia('(max-width:900px)').matches;
            document.body.classList.toggle('show-backdrop', small && !collapsed);
            navToggleBtn.innerHTML = collapsed ? '▶' : '◀';
            navToggleBtn.setAttribute('aria-expanded', (!collapsed).toString());
        }
        navToggleBtn.addEventListener('click', () => {
            const collapsed = !document.body.classList.contains('sidebar-collapsed');
            setSidebarCollapsed(collapsed);
        });
        backdrop.addEventListener('click', () => setSidebarCollapsed(true));
        window.addEventListener('keydown', e => {
            if (e.key === 'Escape') setSidebarCollapsed(true);
        });
        // Auto collapse on small screens after initial load
        function responsiveInit() {
            const small = window.matchMedia('(max-width:900px)').matches;
            setSidebarCollapsed(small); // collapse by default on small
        }
        window.addEventListener('resize', responsiveInit);
        responsiveInit();
        buttons.toggle.addEventListener('click', () => {
            running = !running;
            buttons.toggle.textContent = running ? 'TẠM DỪNG' : 'TIẾP TỤC';
            overlayMsg.classList.toggle('show', !running);
            statusEl.textContent = running ? 'đang chạy' : 'tạm dừng';
        });
        buttons.jump.addEventListener('click', () => randomJump(true));
        buttons.reset.addEventListener('click', () => initScenario());
        // Đã loại bỏ sự kiện chuyển chế độ cuộn ngang
        addForm.addEventListener('submit', e => {
            e.preventDefault();
            const val = newThoughtInput.value.trim(); if (!val) return;
            const type = pick(TYPES);
            const id = spawnThought(val, type, activeId);
            writeSequence(`<b>Thêm:</b> ${escapeHtml(val)}`);
            focusOn(id);
            newThoughtInput.value = '';
        });
        window.addEventListener('resize', () => { clampAll(); applyCamera(); });
        document.addEventListener('keydown', e => {
            if (e.ctrlKey && e.key.toLowerCase() === 'p') {
                e.preventDefault();
                buttons.toggle.click();
            }
            if (e.ctrlKey && e.key.toLowerCase() === 'r') {
                e.preventDefault();
                initScenario();
            }
            if (e.key === 'j') { randomJump(true); }
        });

        // =============== CAMERA PAN / ZOOM ===============
        const MIN_ZOOM = 0.75;
        const MAX_ZOOM = 1.5;
        const camera = { x: 0, y: 0, scale: 1 };
        let isPanning = false; let panStart = { x: 0, y: 0 }; let camStart = { x: 0, y: 0 };
        function applyCamera() {
            viewEl.style.transform = `translate(${-camera.x}px,${-camera.y}px) scale(${camera.scale})`;
            camHUD.innerHTML = `pan: ${camera.x.toFixed(0)},${camera.y.toFixed(0)}<br>zoom: ${camera.scale.toFixed(2)}x`;
            svg.setAttribute('width', worldWidth);
            svg.setAttribute('height', worldHeight);
        }
        container.addEventListener('mousedown', e => {
            if (!allowPanWithoutAlt && !e.altKey) return; // Giữ Alt để pan (desktop); mobile cho phép tự do
            isPanning = true; panStart = { x: e.clientX, y: e.clientY }; camStart = { x: camera.x, y: camera.y };
            container.style.cursor = 'grabbing';
        });
        window.addEventListener('mousemove', e => {
            if (!isPanning) return;
            const dx = (e.clientX - panStart.x) / camera.scale;
            const dy = (e.clientY - panStart.y) / camera.scale;
            camera.x = Math.max(0, Math.min(worldWidth - container.clientWidth, camStart.x - dx));
            camera.y = Math.max(0, Math.min(worldHeight - container.clientHeight, camStart.y - dy));
            applyCamera();
        });
        window.addEventListener('mouseup', () => { if (isPanning) { isPanning = false; container.style.cursor = ''; } });
        container.addEventListener('wheel', e => {
            if (!e.ctrlKey) return; // Ctrl + lăn để zoom
            e.preventDefault();
            const before = camera.scale;
            const delta = -e.deltaY * 0.01;
            camera.scale = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, camera.scale * (1 + delta)));
            const rect = container.getBoundingClientRect();
            const cx = (e.clientX - rect.left) / before + camera.x;
            const cy = (e.clientY - rect.top) / before + camera.y;
            camera.x = cx - (e.clientX - rect.left) / camera.scale;
            camera.y = cy - (e.clientY - rect.top) / camera.scale;
            camera.x = Math.max(0, Math.min(worldWidth - container.clientWidth, camera.x));
            camera.y = Math.max(0, Math.min(worldHeight - container.clientHeight, camera.y));
            applyCamera();
        }, { passive: false });
        applyCamera();

        // =============== PAN TRÊN THIẾT BỊ CẢM ỨNG ===============
        let allowPanWithoutAlt = false;
        function detectMobile() {
            const coarse = window.matchMedia('(pointer: coarse)').matches;
            const narrow = window.matchMedia('(max-width: 900px)').matches;
            allowPanWithoutAlt = coarse || narrow; // nếu màn hình nhỏ hoặc pointer thô
        }
        detectMobile();
        window.addEventListener('resize', detectMobile);

        // Touch events
        container.addEventListener('touchstart', e => {
            if (e.touches.length !== 1) return;
            if (!allowPanWithoutAlt) return; // nếu không ở mobile vẫn để Alt + chuột
            const t = e.touches[0];
            isPanning = true; panStart = { x: t.clientX, y: t.clientY }; camStart = { x: camera.x, y: camera.y };
        }, { passive: true });
        container.addEventListener('touchmove', e => {
            if (!isPanning || e.touches.length !== 1) return;
            const t = e.touches[0];
            const dx = (t.clientX - panStart.x) / camera.scale;
            const dy = (t.clientY - panStart.y) / camera.scale;
            camera.x = Math.max(0, Math.min(worldWidth - container.clientWidth, camStart.x - dx));
            camera.y = Math.max(0, Math.min(worldHeight - container.clientHeight, camStart.y - dy));
            applyCamera();
        }, { passive: true });
        const endTouch = () => { if (isPanning) { isPanning = false; } };
        container.addEventListener('touchend', endTouch);
        container.addEventListener('touchcancel', endTouch);

        // =============== KHỞI CHẠY ===============
        initScenario();
        requestAnimationFrame(loop);
    </script>
</body>

</html>